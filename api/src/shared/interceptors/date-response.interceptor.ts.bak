import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

/**
 * Enhanced interceptor for precise date field synchronization
 * Response dates are already in UTC format - no conversion needed since frontend expects UTC
 * Special handling for ngaygiao, ngaynhan fields
 */
@Injectable()
export class DateResponseInterceptor implements NestInterceptor {
  constructor() {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map(data => this.transformDatesInResponse(data, context))
    );
  }

  /**
   * Transform dates in response - since frontend expects UTC, return as-is
   * @param data Response data
   * @param context Execution context for logging
   * @returns Data v·ªõi dates ƒë√£ ƒë∆∞·ª£c synchronized
   */
  private transformDatesInResponse(data: any, context?: ExecutionContext): any {
    if (!data) return data;
    if (context) {
      const request = context.switchToHttp?.()?.getRequest?.();
      const endpoint = request?.url || 'unknown';
      
      if (endpoint.includes('dathang') || endpoint.includes('donhang')) {
        console.log(`üì§ Enhanced date response transform for ${endpoint}`);
      }
    }

    // N·∫øu l√† array
    if (Array.isArray(data)) {
      return data.map(item => this.transformDatesInObject(item));
    }

    // N·∫øu l√† object
    if (typeof data === 'object') {
      return this.transformDatesInObject(data);
    }

    return data;
  }

  /**
   * Enhanced transform dates trong m·ªôt object v·ªõi special handling
   * @param obj Object c·∫ßn transform
   * @returns Object v·ªõi dates ƒë√£ ƒë∆∞·ª£c synchronized
   */
  private transformDatesInObject(obj: any): any {
    if (!obj || typeof obj !== 'object') return obj;

    const transformed = { ...obj };

    // Priority date fields requiring enhanced synchronization
    const criticalDateFields = ['ngaygiao', 'ngaynhan'];
    const commonDateFields = [
      'createdAt', 'updatedAt', 'ngaytao', 'ngaycapnhat',
      'batdau', 'ketthuc', 'startDate', 'endDate', 'date', 'datetime', 'ngay'
    ];

    Object.keys(transformed).forEach(key => {
      const value = transformed[key];

      // Enhanced handling for critical date fields
      if (criticalDateFields.includes(key) && this.isDateValue(value)) {
        try {
          // Ensure proper UTC format for critical fields
          const utcDate = this.timezoneUtil.toUTC(value);
          transformed[key] = new Date(utcDate).toISOString();
          
          console.log(`üì§ Response transform ${key}: ${value} ‚Üí ${transformed[key]}`);
        } catch (error) {
          console.error(`‚ùå Error transforming ${key}:`, error);
          transformed[key] = value; // Keep original on error
        }
      }
      // Standard handling for other date fields
      else if (commonDateFields.includes(key) && this.isDateValue(value)) {
        // Ensure UTC ISO string format for consistency
        transformed[key] = value instanceof Date ? value.toISOString() : value;
      }
      // Nested objects or arrays
      else if (value && typeof value === 'object') {
        transformed[key] = this.transformDatesInResponse(value);
      }
    });

    return transformed;
  }

  /**
   * Ki·ªÉm tra value c√≥ ph·∫£i l√† date kh√¥ng
   * @param value Value c·∫ßn ki·ªÉm tra
   * @returns true n·∫øu l√† date
   */
  private isDateValue(value: any): boolean {
    if (!value) return false;

    // N·∫øu l√† Date object
    if (value instanceof Date) return true;

    // N·∫øu l√† string c√≥ format ISO date
    if (typeof value === 'string') {
      // Check ISO format v·ªõi timezone (c√≥ T v√† Z ho·∫∑c offset)
      const isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z|[+-]\d{2}:\d{2})$/;
      return isoRegex.test(value);
    }

    return false;
  }
}
